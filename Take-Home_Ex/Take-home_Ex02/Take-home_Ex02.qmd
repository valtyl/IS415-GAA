---
title: "Take-home Exercise 2: Spatio-temporal Analysis of COVID-19 Vaccination Trends at the Sub-district Level, DKI Jakarta"
execute: 
  message: true
  warning: false
  echo: true
  eval: true
date: "13 February 2023"
date-modified: "`r Sys.Date()`"
# number-sections: true
editor: visual
format: html
author: Valencia
---

# 1 Setting the Scene

Since late December 2019, an outbreak of a novel coronavirus disease (COVID-19; previously known as 2019-nCoV) was reported in Wuhan, China, which had subsequently affected 210 countries worldwide. In general, COVID-19 is an acute resolved disease but it can also be deadly, with a 2% case fatality rate.

The COVID-19 vaccination in Indonesia is an ongoing mass immunisation in response to the COVID-19 pandemic in Indonesia. On 13 January 2021, the program commenced when President Joko Widodo was vaccinated at the presidential palace. In terms of total doses given, Indonesia ranks third in Asia and fifth in the world.

According to wikipedia, as of 5 February 2023 at 18:00 WIB (UTC+7), 204,266,655 people had received the first dose of the vaccine and 175,131,893 people had been fully vaccinated; 69,597,474 of them had been inoculated with the booster or the third dose, while 1,585,164 had received the fourth dose. Jakarta has the highest percentage of population fully vaccinated with 103.46%, followed by Bali and Special Region of Yogyakarta with 85.45% and 83.02% respectively.

Despite its compactness, the cumulative vaccination rate are not evenly distributed within DKI Jakarta. The question is where are the sub-districts with relatively higher number of vaccination rate and how they changed over time.

# 2 Objectives

Exploratory Spatial Data Analysis (ESDA) hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate Local Indicators of Spatial Association (LISA) and Emerging Hot Spot Analysis (EHSA) to undercover the spatio-temporal trends of COVID-19 vaccination in DKI Jakarta.

# 3 The Data

## 3.1 Aspatial Data

For the purpose of this assignment, data from [Riwayat File Vaksinasi DKI Jakarta](https://riwayat-file-vaksinasi-dki-jakarta-jakartagis.hub.arcgis.com/) will be used. Daily vaccination data are provides. You are only required to download either the first day of the month or last day of the month of the study period.

## 3.2 Geospatial Data

For the purpose of this study, DKI Jakarta administration boundary 2019 will be used. The data set can be downloaded at Indonesia Geospatial portal, specifically at [this page](https://www.indonesia-geospasial.com/2020/04/download-shapefile-shp-batas-desa.html).

::: callout-note
-   The national Projected Coordinates Systems of Indonesia is DGN95 / Indonesia TM-3 zone 54.1.
-   Exclude all the outer islands from the DKI Jakarta sf data frame, and
-   Retain the first nine fields in the DKI Jakarta sf data frame. The ninth field JUMLAH_PEN = Total Population.
:::

# 4 Getting Started

## 4.1 Installing and Loading R packages

-   [sf](https://r-spatial.github.io/sf/): to import, manage, and process geospatial data
-   [tidyverse](https://www.tidyverse.org/): a collection of packages ([readr](https://readr.tidyverse.org/) for importing delimited text file, [tidyr](https://tidyr.tidyverse.org/) for tidying data, [dplyr](https://dplyr.tidyverse.org/) for wrangling data)
-   [tmap](https://cran.r-project.org/web/packages/tmap/): provides functions for plotting cartographic quality static point patterns maps or interactive maps
-   [sfdep](https://cran.r-project.org/web/packages/sfdep/): for spatial dependence of simple features
-   [readxl](https://readxl.tidyverse.org/reference/read_excel.html): for importing Excel worksheets(.xlsx)
-   [plyr](https://cran.r-project.org/package=plyr): for splitting data, applying functions and combining results
-   [kableExtra](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html): for table customisation
-   [Kendall](https://cran.r-project.org/package=Kendall): for Mann-Kendall Test
-   [plotly](https://cran.r-project.org/package=plotly) for creating interactive web-based graphs

```{r}
#| code-fold: true
#| code-summary: Show the code!
pacman::p_load(sf, sfdep, readxl, plyr, kableExtra, tmap, Kendall, plotly, tidyverse)
```

## 4.2 Data Wrangling: Geospatial Data

### 4.2.1 Importing the Geospatial Data

```{r}
#| code-fold: true
#| code-summary: Show the code!
# bd stands for "batas desa", translated as "village boundary"
# reads in geospatial data and stores into bd_jakarta dataframe
bd_jakarta <- st_read(dsn = "data/geospatial",
                       layer = "BATAS_DESA_DESEMBER_2019_DUKCAPIL_DKI_JAKARTA")
```

From the output message, we learn that:

-   Geometry type: Multipolygon
-   269 features, 161 fields
-   Assigned CRS is [WGS 84](https://epsg.io/4326), 'World Geodetic System 1984' (This is not appropriate as this geospatial dataset is Indonesian-specific hence we will have to use the national CRS of Indonesia, [DGN 95](https://epsg.io/23845), 'Datum Geodesi Nasional 1995'. We will change this later on.) (Refer to note in section 3.2)

### 4.2.2 Data Pre-Processing

Before visualising our data, we need to check if there are:

-   invalid geometries
-   or missing values

These can impact future calculations and representations

#### 4.2.2.1 Invalid Geometries

Checking for invalid geometries:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# function breakdown:
# the st_is_valid function checks whether a geometry is valid
# which returns the indices of certain values based on logical conditions
# length returns the length of data objects

# checks for the number of geometries that are NOT valid
length(which(st_is_valid(bd_jakarta) == FALSE))
```

The message output shows that there are no invalid geometries.

#### 4.2.2.2 Missing Values

```{r}
#| code-fold: true
#| code-summary: Show the code!
# the rowSums(is.na(bd_jakarta))!=0 checks every row if there are NA values, returning TRUE or FALSE
# the bd_jakarta 'wrapper' prints said rows that contain NA values
bd_jakarta[rowSums(is.na(bd_jakarta))!=0,]
```

The message output shows that there are 2 rows with missing values for the columns `KAB_KOTA` (City), `KECAMATAN` (District), `DESA_KELUR` (Village) and a few more others. We can also see that there are way too many columns, and we will remove the unnecessary columns later on.

To clean up, we will remove the rows that have NA values in `DESA_KELUR` since we are interested in the dataset on a sub-district level:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# removes rows that have an NA value in DESA_KELUR
# in context of this data, we can use other columns, such as KAB_KOTA or KECAMATAN
# but since we're looking at this on a sub-district level, DESA_KELUR seemed most appropriate
bd_jakarta <- na.omit(bd_jakarta,c("DESA_KELUR"))
```

#### 4.2.2.3 Verifying & Transforming the Coordinate System

Checking the CRS of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# retrieves the coordinate system of bd_jakarta
st_crs(bd_jakarta)
```

As mentioned in section 4.2.1, WGS 84 is not appropriate and we should change it to DGN 95:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# transforms the CRS to DGN95, ESPG code 23845
bd_jakarta <- st_transform(bd_jakarta, 23845)
```

Checking if the CRS has been properly assigned:

```{r}
#| code-fold: true
#| code-summary: Show the code!
st_crs(bd_jakarta)
```

The transformation is done.

### 4.2.3 Data Visualisation

First, we will visualise the geometry of Jakarta:

```{r}
#| code-fold: true
#| code-summary: Show the code!
plot(st_geometry(bd_jakarta))
```

From the output, it shows that `bd_jakarta` includes the main land but also many other outer islands that we are not relevant to our analysis in this assignment. (Refer to note in section 3.2)

To remove the outer islands, we should look at how unique values at the City level, `KAB_KOTA`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# outputs unique values of the KAB_KOTA field
unique(bd_jakarta$"KAB_KOTA")
```

From the output, the cities within Jakarta have a JAKARTA prefix, while KEPULAUAN SERIBU (which means 'Thousand Islands') refers to the outer islands. Visualising `KAB_KOTA` will confirm this:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# with bd_jakarta as the input data (setting the 'base')
# draw the KAB_KOTA (city) polygons
# essentially shades the map according to the city divisions
tm_shape(bd_jakarta) + 
  tm_polygons("KAB_KOTA")
```

The above visualisation proves that KEPULAUAN SERIBU are the outer islands to remove:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# filters out the outer islands by accepting only if the value of KAB_KOTA is NOT KEPULAUAN SERIBU
bd_jakarta <- filter(bd_jakarta, KAB_KOTA != "KEPULAUAN SERIBU")
```

### 4.2.4 Retaining relavant columns only

As seen in section 4.2.2.2, there were many unnecessary and irrelevant columns that we could remove. (Refer to note in section 3.2)

Retaining the relevant fields (first 9 fields) for our analysis:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# filters out other fields by accepting only the first 9 fields
bd_jakarta <- bd_jakarta[, 0:9]
```

### 4.2.5 Renaming the Columns in English

For ease of comprehension:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# with reference to: https://www.codegrepper.com/code-examples/r/rename+column+name+in+r
# renames the columns in the style New_Name = OLD_NAME
bd_jakarta <- bd_jakarta %>% 
  dplyr::rename(
    Object_ID=OBJECT_ID,
    Province=PROVINSI, 
    City=KAB_KOTA, 
    District=KECAMATAN, 
    Village_Code=KODE_DESA, 
    Village=DESA, 
    Sub_District=DESA_KELUR,
    Code=KODE, 
    Total_Population=JUMLAH_PEN
    )
```

### 4.2.6 Brief EDA of Geospatial Data

Summary of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# reveals the data type of all fields + some values
glimpse(bd_jakarta)
```

Number of unique sub-districts:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"Sub_District"))
```

Number of unique districts:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"District"))
```

Number of unique cities:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"City"))
```

There are 261 unique sub-districts, 42 unique districts and 5 unique cities. The maximum number of categories for mapping with tmap is 30. Even though max.categories can be adjusted in tmap_options, too many segmented sections on a single map will not provide much insights hence we should do the EDA at 'City' level:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# shades the map according to the city divisions
tm_shape(bd_jakarta) + 
  tm_polygons("City")
```

## 4.3 Data Wrangling: Aspatial Data

### 4.3.1 Pre-Importing EDA

For the aspatial data, I have decided to download the data for last day of every month from July 2021 to June 2022. However, the last day of Feb 2022 provided on the website in section 3.1 is 27 Feb instead of 28 Feb.

This section is to check for any discrepancies in each .xlsx file in the 'data/aspatial' folder by performing EDA:

```{r}
#| code-fold: true
#| code-summary: Show the code!
jul2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Juli 2021).xlsx")
glimpse(jul2021)
```

The above output shows that there are no duplicates for the columns.

Below, similar codes were used to check for the other excel files. There are no duplicates in the rest of the files. Doing a quick comparison, we can notice that the excel files for July 2021 to February 2022 have 27 columns while those for March 2022 to June 2022 have 34 columns.

```{r}
#| code-fold: true
#| code-summary: Show the code!
aug2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Agustus 2021).xlsx")
glimpse(aug2021)

sep2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 September 2021).xlsx")
glimpse(sep2021)

oct2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Oktober 2021).xlsx")
glimpse(oct2021)

nov2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 November 2021).xlsx")
glimpse(nov2021)

dec2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Desember 2021).xlsx")
glimpse(dec2021)

jan2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Januari 2022).xlsx")
glimpse(jan2022)

feb2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (27 Februari 2022).xlsx")
glimpse(feb2022)

mar2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Maret 2022).xlsx")
glimpse(mar2022)

apr2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 April 2022).xlsx")
glimpse(apr2022)

may2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Mei 2022).xlsx")
glimpse(may2022)

jun2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 Juni 2022).xlsx")
glimpse(jun2022)
```

### 4.3.2 Creating an Aspatial Data Pre-processing Function

Firstly, here are some requirements for our aspatial data:

Columns of interest:

-   KODE KELURAHAN: sub-district code
-   KELURAHAN: sub-district
-   SASARAN: target
-   BELUM VAKSIN: not yet vaccinated

We need to create an extra Date column that has the month and year of the observation. Note that the files have a naming convention "Data Vaksinasi Berbasis Kelurahan (DD Month YYYY).xlsx"

```{r}
#| code-fold: true
#| code-summary: Show the code!
# takes in an aspatial data filepath and returns a processed output
aspatial_preprocess <- function(filepath){
  # we use [-1,] to remove the first row of the file as the first row is a subheader row
  result_file <- read_xlsx(filepath)[-1,]
  
  # Create the Date Column
  # the format of our files is: Data Vaksinasi Berbasis Kelurahan (DD Month YYYY)
  # while the start is technically "(", "(" is part of a regular expression and leads to a warning message, so we'll use "Kelurahan" instead. The [[1]] refers to the first element in the list.
  # we're loading it as DD-Month-YYYY format
  # to get the end index, we use the length of the filepath - 6 
  # as such, the most relevant functions are substr (returns a substring) and either str_locate (returns location of substring as an integer matrix) or gregexpr (returns a list of locations of substring)
  # reference https://stackoverflow.com/questions/14249562/find-the-location-of-a-character-in-string
  startpoint <- gregexpr(pattern="Kelurahan", filepath)[[1]] + 11
  
  result_file$Date <- substr(filepath, startpoint, nchar(filepath)-6)
  
  # Retain the Relevant Columns
  result_file <- result_file %>% 
    select("Date", 
           "KODE KELURAHAN", 
           "KELURAHAN", 
           "SASARAN", 
           "BELUM VAKSIN")
  return(result_file)
}
```

### 4.3.3 Importing the Aspatial Data

Feeding Files into the `aspatial_preprocess` function using list.files() and [lapply()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply) to apply a function to all elements in the list:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# in the folder 'data/aspatial', find files with the extension '.xlsx' and add it to our fileslist 
# the full.names=TRUE prepends the directory path to the file names, giving a relative file path - otherwise, only the file names (not the paths) would be returned 
# reference: https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html
fileslist <-list.files(path = "data/aspatial", pattern = "*.xlsx", full.names=TRUE)

# afterwards, for every element in fileslist, apply aspatial_process function
dflist <- lapply(seq_along(fileslist), function(x) aspatial_preprocess(fileslist[x]))
```

Converting the `dflist` into an actual dataframe using [ldply()](https://www.rdocumentation.org/packages/plyr/versions/1.8.6/topics/ldply):

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta <- ldply(dflist, data.frame)
```

Checking `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
glimpse(vacc_jakarta)
```

### 4.3.4 Formatting Date Column

The Dates are currently in string format as there were derived from the file names, hence we need to convert the Dates into datetime format.

```{r}
#| code-fold: true
#| code-summary: Show the code!
# parses the 'Date' column into Month(Full Name)-YYYY datetime objects
# reference: https://stackoverflow.com/questions/53380650/b-y-date-conversion-gives-na

# locale="ind" means that the locale has been set as Indonesia
Sys.setlocale(locale="ind")
```

Converting to datetime format:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta$Date <- c(vacc_jakarta$Date) %>% 
  as.Date(vacc_jakarta$Date, format ="%d %B %Y")

glimpse(vacc_jakarta)
```

### 4.3.4 Renaming Columns to English

Renaming columns to English for ease of comprehension:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# renames the columns in the style New_Name = OLD_NAME
vacc_jakarta <- vacc_jakarta %>% 
  dplyr::rename(
    Date=Date,
    Sub_District_Code=KODE.KELURAHAN,
    Sub_District=KELURAHAN, 
    Target=SASARAN, 
    Not_Yet_Vaccinated=BELUM.VAKSIN
    )
```

### 4.3.5 Further Data Processing

After finalising the dataframe, we can proceed with other data processing requirements.

Checking for missing values:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# returns rows that contain NA values
vacc_jakarta[rowSums(is.na(vacc_jakarta))!=0,]
```

From the output, there are no missing values.

## 4.3 Geospatial Data Integration

### 4.3.1 Preliminary joining + EDA

We need to join the geospatial and aspatial data frames but we first need to see what they both commonly have.

Check column names of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
colnames(bd_jakarta)
```

Check column names of `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
colnames(vacc_jakarta)
```

We are able to see that we can join the dataframes with `Sub_District` and `Sub_District_Code`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta <- left_join(bd_jakarta, vacc_jakarta,
                              by=c(
                                "Sub_District"="Sub_District", 
                             "Village_Code"="Sub_District_Code")
                              )
```

Visualising `combined_jakarta` in terms of:

-   population not yet vaccinated
-   target population to be vaccinated
-   total population

```{r}
#| code-fold: true
#| code-summary: Show the code!

not_yet_vaccinated = tm_shape(combined_jakarta)+
  tm_fill("Not_Yet_Vaccinated") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Not Yet Vaccinated Count")

target = tm_shape(combined_jakarta)+
  tm_fill("Target") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Target Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Total Count")

tmap_arrange(not_yet_vaccinated, target, total_population)
```

Checking for empty rows in `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta[rowSums(is.na(vacc_jakarta))!=0,]
```

Checking for empty rows in `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
bd_jakarta[rowSums(is.na(bd_jakarta))!=0,]
```

There are some missing values in the visualisations even though there are no rows with missing values in `vacc_jakarta` and `bd_jakarta` individually. This could be due to the mismatch in the values due to slightly different namings for the same sub-district when the left join was done.

### 4.3.2 Identifying Mismatched Sub-District Records

Checking for unique values of Sub-District in `vacc_jakarta` but not in `bd_jakarta` and vice versa:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_subdistrict <- c(vacc_jakarta$Sub_District)
bd_subdistrict <- c(bd_jakarta$Sub_District)

unique(vacc_subdistrict[!(vacc_subdistrict %in% bd_subdistrict)])
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
unique(bd_subdistrict[!(bd_subdistrict %in% vacc_subdistrict)])
```

Table to view difference in naming:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# initialise a dataframe of our cases vs bd subdistrict spelling
spelling <- data.frame(
  Aspatial_Cases=c("BALE KAMBANG", "HALIM PERDANA KUSUMAH", "JATI PULO", "KAMPUNG TENGAH", "KERENDANG", "KRAMAT JATI", "PAL MERIAM", "PINANG RANTI", "RAWA JATI"),
  Geospatial_BD=c("BALEKAMBAG", "HALIM PERDANA KUSUMA", "JATIPULO", "TENGAH", "KRENDANG", "KRAMATJATI", "PALMERIAM", "PINANGRANTI", "RAWAJATI")
  )

# with dataframe a input, outputs a kable
library(knitr)
library(kableExtra)
kable(spelling, caption="Mismatched Records") %>%
  kable_material("hover", latex_options="scale_down")
```

Correcting the mismatched sub-district records in `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# where bd_jakarta is a mismatched value, replace with the correct value
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'BALEKAMBANG'] <- 'BALE KAMBANG'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'HALIM PERDANA KUSUMA'] <- 'HALIM PERDANA KUSUMAH'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'JATIPULO'] <- 'JATI PULO'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KALI BARU'] <- 'KALIBARU'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'TENGAH'] <- 'KAMPUNG TENGAH'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KRAMATJATI'] <- 'KRAMAT JATI'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KRENDANG'] <- 'KERENDANG'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'PALMERIAM'] <- 'PAL MERIAM'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'PINANGRANTI'] <- 'PINANG RANTI'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'RAWAJATI'] <- 'RAWA JATI'
```

There are 6 more unique values in `vacc_jakarta` as those values are data referring to the outer islands looking at the fact that the rows under the column "WILAYAH KOTA" do not have the word "JAKARTA", meaning that these places are not in Jakarta:

![](images/jakarta_outer_islands.png)

Thus, we need to remove the rows with these outer islands data:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta <- vacc_jakarta[!(vacc_jakarta$Sub_District=="PULAU HARAPAN" | vacc_jakarta$Sub_District=="PULAU KELAPA" | vacc_jakarta$Sub_District=="PULAU PANGGANG" | vacc_jakarta$Sub_District=="PULAU PARI" | vacc_jakarta$Sub_District=="PULAU TIDUNG" | vacc_jakarta$Sub_District=="PULAU UNTUNG JAWA"), ]
```

Re-checking for rows with NA values in `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta[rowSums(is.na(vacc_jakarta))!=0,]
```

Re-checking for rows with NA values in `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
bd_jakarta[rowSums(is.na(bd_jakarta))!=0,]
```

### 4.3.3 Re-joining the geospatial and aspatial data frames + EDA

```{r}
#| code-fold: true
#| code-summary: Show the code!
# joins vacc_jakarta to bd_jakarta based on Sub_District
combined_jakarta <- left_join(bd_jakarta, vacc_jakarta,
                              by=c("Sub_District"="Sub_District")
                              )
```

Checking for rows with NA values in `combined_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta[rowSums(is.na(combined_jakarta))!=0,]
```

Visualising `combined_jakarta` again in terms of :

-   population not yet vaccinated
-   target population to be vaccinated
-   total population

```{r}
#| code-fold: true
#| code-summary: Show the code!
not_yet_vaccinated = tm_shape(combined_jakarta)+
  tm_fill("Not_Yet_Vaccinated") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Not Yet Vaccinated Count")

target = tm_shape(combined_jakarta)+
  tm_fill("Target") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Target Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Total Count")

tmap_arrange(not_yet_vaccinated, target, total_population)
```

## 4.4 Calculation for Vaccination Rate

We need to compute the monthly vaccination rate:

-   vaccination rate (in %) = (target - number of people not vaccinated yet) / target \* 100

Note: We will use "target number of people to vaccinate" instead of "total population" to calculate the vaccination rate as Indonesia excludes people age 14 and below for vaccination.

```{r}
#| code-fold: true
#| code-summary: Show the code!
# grouping based on the sub-district and date
# the cumulative_case_rate is based on the sum of cases over the total population
vacc_rate <- vacc_jakarta %>%
  inner_join(bd_jakarta, by=c("Sub_District" = "Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`vacc_rate` = ((Target-Not_Yet_Vaccinated)/Target)*100) %>%
  
  #afterwards, pivots the table based on the Dates, using the cumulative case rate as the values
  ungroup() %>% pivot_wider(names_from = Date,
              values_from = vacc_rate)
```

Show Vaccination Rate:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_rate
```

### 4.4.1 Converting dataframes to sf objects

Before moving on to mapping, we should convert dataframes into sf objects

Converting `combined_jakarta` and `vacc_rate`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta <- st_as_sf(combined_jakarta)

# need to join our previous dataframes with the geospatial data to ensure that geometry column is present
vacc_rate <- vacc_rate%>% left_join(bd_jakarta, by=c("Sub_District"="Sub_District"))
vacc_rate <- st_as_sf(vacc_rate)
```

## 4.5 Choropleth Mapping and Analysis

There are different data classifications to choropleth maps like equal intervals, quantile, Jenks and standard deviation. I have decided to use Jenks as it minimises variation in each class. It will be able to find suitable class ranges and also group outliers in a class of its own.

### 4.5.1 Jenks Choropleth Map

As we do not want too many classes, we will use 6 classes as it seems to be the optimum number to view different classes and we will be able to differentiate between the classes without straining our eyes.

Map for July 2021:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# using the jenks method, with 6 classes
tmap_mode("plot")
tm_shape(vacc_rate)+
  tm_fill("2021-07-31", 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
  tm_layout(main.title = "Distribution of Vaccination Rate in July 2021",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.5, 
            legend.width = 0.4,
            frame = TRUE) +
  tm_borders(alpha = 0.5)
```

Introducing a helper function to help us plot the maps for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# input: the dataframe and the variable name - in this case, the month 
# with style="jenks" for the jenks classification method
jenks_plot <- function(df, varname) {
  tm_shape(vacc_rate) +
    tm_polygons() +
  tm_shape(df) +
    tm_fill(varname, 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
    tm_layout(main.title = varname,
          main.title.position = "center",
          main.title.size = 1.2,
          legend.height = 0.45, 
          legend.width = 0.35,
          frame = TRUE) +
    tm_borders(alpha = 0.5)
}
```

Visualising the Jenks Maps for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2021-07-31"),
             jenks_plot(vacc_rate, "2021-08-31"),
             jenks_plot(vacc_rate, "2021-09-30"),
             jenks_plot(vacc_rate, "2021-10-31"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2021-11-30"),
             jenks_plot(vacc_rate, "2021-12-31"),
             jenks_plot(vacc_rate, "2022-01-31"),
             jenks_plot(vacc_rate, "2022-02-27"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2022-03-31"),
             jenks_plot(vacc_rate, "2022-04-30"),
             jenks_plot(vacc_rate, "2022-05-31"),
             jenks_plot(vacc_rate, "2022-06-30"))
```

### 4.5.2 Observations from Jenks Choropleth Maps

For each map, they have their own relative vaccination rate as the range for each map differs. Hence, we cannot rely on the colour scale for each map to compare between the months as it would not be fair.

However, we are able to compare each month individually and see that typically for each month, generically the higher vaccination rates are at the Central area and Southern area. Although there were higher vaccination rates initially at the Northern area.

Some other analysis can be done like the sub-district with the highest vaccination rate and the sub-district with the lowest vaccination rate for each month:

```{r}
#| code-fold: true
#| code-summary: Show the code!
#highest vaccination rate for each month
vacc_rate$Sub_District[which.max(vacc_rate$`2021-07-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-08-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-09-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-10-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-11-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-12-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-01-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-02-27`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-03-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-04-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-05-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-06-30`)]
```

From this, we can tell that the sub-district "KAMAL MUARA" had the highest vaccination rate initially from July 2021 to August 2021 but thereafter, "HALIM PERDANA KUSMAH" consistently had the highest vaccination rate from September 2021 to June 2022.

```{r}
#| code-fold: true
#| code-summary: Show the code!
#lowest vaccination rate for each month
vacc_rate$Sub_District[which.min(vacc_rate$`2021-07-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-08-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-09-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-10-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-11-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-12-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-01-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-02-27`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-03-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-04-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-05-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-06-30`)]
```

From this, we can tell that initially the sub-district "BALE KAMBANG" had the lowest vaccination rate in July 2021, and "PETAMBURAN" was the sub-district with the lowest vaccination rate in August 2021. But their vaccination rates improved over the months such that "KALIBARU" was identified as the sub-district with the lowest vaccination rate from September 2021 to January 2022 with the exception of December 2021. Then, "KEBON MELATI" became the sub-district with the lowest vaccination rate from December 2021 to June 2022 with the exception of January 2022.

### 4.5.3 Spatio-Temporal Mapping with custom breakpoints

In the above section, each month had their own vaccination rate. To compare with the vaccination rate between months and see the spatio-temporal progression of the vaccination rates, we should set a fixed range.

To do so, we have to customise the breakpoints and following the above section, we will define 6 breakpoints.

First, we require the maximum vaccination rate which would be from the latest month (June 2022):

```{r}
#| code-fold: true
#| code-summary: Show the code!
max(vacc_rate$`2022-06-30`)
```

Now, we can define the 6 breakpoints based on the Jenks breaks ranges from the above section:

```{r}
#| code-fold: true
#| code-summary: Show the code!
breakpoints = c(37, 55, 72, 80, 84, 90)
```

Creating a helper function for break plot:

```{r}
break_plot <- function(df, varname) {
  tm_shape(vacc_rate) +
    tm_polygons() +
  tm_shape(df) +
    tm_fill(varname, 
          breaks= breakpoints,
          title = "Vaccination Rate") +
    tm_layout(main.title = varname,
          main.title.position = "center",
          main.title.size = 1.2,
          legend.height = 0.45, 
          legend.width = 0.35,
          frame = TRUE) +
    tm_borders(alpha = 0.5)
}
```

Plotting the custom break plots for each month:

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2021-07-31"),
             break_plot(vacc_rate, "2021-08-31"),
             break_plot(vacc_rate, "2021-09-30"),
             break_plot(vacc_rate, "2021-10-31"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2021-11-30"),
             break_plot(vacc_rate, "2021-12-31"),
             break_plot(vacc_rate, "2022-01-31"),
             break_plot(vacc_rate, "2022-02-27"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2022-03-31"),
             break_plot(vacc_rate, "2022-04-30"),
             break_plot(vacc_rate, "2022-05-31"),
             break_plot(vacc_rate, "2022-06-30"))
```

### 4.5.4 Observations from Custom Breakplot Maps

![](images/ezgif.com-gif-maker%20(1).gif){fig-align="center"}

At the start, in July 2021, there is a slightly higher vaccination rate at the Northern and Central area compared to the other areas given its slightly darker shade of yellow.

However as time passes, from August 2021 to October 2021, the increase in the vaccination rate becomes greater at the Northern Central area and Southern area.

Specifically sub-district "HALIM PERDANA KUSUMAH" is obvious to the eye with its consistently high rate and darker shade at the Eastern border.

From November 2021 to February 2022, the increase in vaccination rate is faster at the Southern area and the Northern Central Area.

(Supplementing the previous observations in section 4.5.2, the general increasing trend happens at the Southern and Central area.)

From March 2022 to June 2022, we can see the sub-districts at the Northern Central area as well as some sub-districts near the Eastern border increasing their vaccination rates.

## 4.6 Local Gi\* Analysis

### 4.6.1 Computing local Gi\* values of the monthly vaccination rate

To create a time series cube, we first have to make an attribute table with the data organised in the following format: Date, Location (`Sub_District`) and Value (`Vaccination_Rate`)

Making an attribute table:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# make new vaccination attribute table with Date, Sub_District, Target, Not_Yet_Vaccinated
vacc_attribute_table <- combined_jakarta %>% select(10, 8, 12, 13) %>% st_drop_geometry()

# add a new field for Vaccination_Rate
vacc_attribute_table$Vaccination_Rate <- (vacc_attribute_table$Target - vacc_attribute_table$Not_Yet_Vaccinated) / vacc_attribute_table$Target*100

# final vaccination attribute table with Date, Sub_District, Vaccination_Rate
vacc_attribute_table <- tibble(vacc_attribute_table %>% select(1,2,5))
```

Display attribute table details:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_attribute_table
```

Creating a time series cube (spatio-temporal cube) using `spacetime()` of sfdep package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_rate_st <- spacetime(vacc_attribute_table, bd_jakarta,
                          .loc_col = "Sub_District",
                          .time_col = "Date")
```

Next, we can check if `vacc_rate_st` is indeed a space-time cube object using `is_spacetime_cube()` of sfdep package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
is_spacetime_cube(vacc_rate_st)
```

The output shows 'TRUE', confirming that `vacc_rate_st` is a space-time cube.

To compute the local Gi\* statistics, we need to derive the spatial weights first:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_rate_nb <- vacc_rate_st %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale=1,
                                  alpha=1),
         .before=1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

The above code does the following:

-   identify neighbours
-   derive inverse distance weights
-   `activate()` of dplyr package is used to activate the geometry context
-   `mutate()` of dplyr package is used to create two new columns nb and wt.
-   Then we will activate the data context again and copy over the nb and wt columns to each time-slice using `set_nbs()` and `set_wts()`
-   row order is very important so do not rearrange the observations after using `set_nbs()` or `set_wts()`.

The dataset now has neighbours and weights for each time-slice:

```{r}
#| code-fold: true
#| code-summary: Show the code!
head(vacc_rate_nb)
```

Before computing Gi\*, we will set the seed value so that the results of the simulations will be reproducible and constant:

```{r}
#| code-fold: true
#| code-summary: Show the code!
set.seed(1234)
```

Computing Gi\* for each location, grouping by Date and using `local_gstar_perm()` of sfdep package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
gi_stars <- vacc_rate_nb |>
  group_by(Date) |>
  mutate(gi_star = local_gstar_perm(
    Vaccination_Rate, nb, wt, nsim=99)) |>
      tidyr::unnest(gi_star)
```

Note: `unnest()` will unnest the `gi_star` column

Taking a look at the newly created `gi_stars` dataframe:

```{r}
#| code-fold: true
#| code-summary: Show the code!
gi_stars
```

### 4.6.2 Displaying the Gi\* maps of the monthly vaccination rate

Before we can visualise the Gi\* values using maps, we need to join both `combined_jakarta` and `gi_stars` together:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta_gi_stars <- combined_jakarta %>%
  left_join(gi_stars)
```

Taking a look at `combined_jakarta_gi_stars`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta_gi_stars
```

Visualising Gi\* and p-value of Gi\* (only significant locations where p-value \< 0.05) for vaccination rates in July 2021:

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
gi_star_map = tm_shape(filter(combined_jakarta_gi_stars, Date == '2021-07-31')) +
  tm_fill("gi_star") +
  tm_borders(alpha=0.5) +
  tm_layout(main.title = "Gi* values for vaccination rates in July 2021", main.title.size=0.8)
  # tm_view(set.zoom.limits = c(10,16))

p_sim_map = tm_shape(filter(combined_jakarta_gi_stars, Date == '2021-07-31')) +
  tm_fill("p_sim", breaks = c(0, 0.05, 1)) +
  tm_borders(alpha=0.5) + 
  tm_layout(main.title = "p-values of Gi* for vaccination rates in July 2021", main.title.size=0.8)
  # tm_view(set.zoom.limits = c(10,16))

tmap_arrange(gi_star_map, p_sim_map)

```

Introducing a helper function to help us plot the Gi\* and p-value of Gi\* maps for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
gi_star_plot <- function(date, month) {
  gi_star_map = tm_shape(filter(combined_jakarta_gi_stars, Date == date)) +
    tm_fill("gi_star") +
    tm_borders(alpha=0.5) +
    tm_layout(main.title = paste("Gi* values for vaccination rates in", month), main.title.size=0.8)

  p_sim_map = tm_shape(filter(combined_jakarta_gi_stars, Date == date)) +
    tm_fill("p_sim", breaks = c(0, 0.05, 1)) +
    tm_borders(alpha=0.5) + 
    tm_layout(main.title = paste("p-values of Gi* for vaccination rates in", month), main.title.size=0.8)

  tmap_arrange(gi_star_map, p_sim_map)
}
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
gi_star_plot("2021-07-31", "July 2021")
gi_star_plot("2021-08-31", "August 2021")
gi_star_plot("2021-09-30", "September 2021")
gi_star_plot("2021-10-31", "October 2021")
gi_star_plot("2021-11-30", "November 2021")
gi_star_plot("2021-12-31", "December 2021")
gi_star_plot("2022-01-31", "January 2022")
gi_star_plot("2022-02-27", "February 2022")
gi_star_plot("2022-03-31", "March 2022")
gi_star_plot("2022-04-30", "April 2022")
gi_star_plot("2022-05-31", "May 2022")
gi_star_plot("2022-06-30", "June 2022")
```

Locations with p-value of Gi\* \< 0.05 in July 2021:

```{r}
#| code-fold: true
#| code-summary: Show the code!
july_details = filter(combined_jakarta_gi_stars, Date == '2021-07-31' & p_sim<0.05)
july_details$Sub_District
```

Introducing a helper function to help us discover the Sub-Districts with p-value of Gi\* \< 0.05 for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
get_significant_locations <- function(date, month) {
  print(paste("Sub-Districts with p-value of Gi* < 0.05 in", month))
  filter(combined_jakarta_gi_stars, Date == date & p_sim<0.05)$Sub_District
}
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
get_significant_locations("2021-07-31", "July 2021")
get_significant_locations("2021-08-31", "August 2021")
get_significant_locations("2021-09-30", "September 2021")
get_significant_locations("2021-10-31", "October 2021")
get_significant_locations("2021-11-30", "November 2021")
get_significant_locations("2021-12-31", "December 2021")
get_significant_locations("2022-01-31", "January 2022")
get_significant_locations("2022-02-27", "February 2022")
get_significant_locations("2022-03-31", "March 2022")
get_significant_locations("2022-04-30", "April 2022")
get_significant_locations("2022-05-31", "May 2022")
get_significant_locations("2022-06-30", "June 2022")
```

Below is a table that summarises the number of times the p-value of Gi\* was less than 0.05 for the respective Sub-Districts in the 12 months period (this table only shows the Sub-Districts with a significant p-value for at least 1 month):

```{r}
#| code-fold: true
#| code-summary: Show the code!
num_of_times = filter(combined_jakarta_gi_stars, p_sim<0.05)
as.data.frame(table(num_of_times$Sub_District))
```

Here is a gif to show how the Gi\* values and their p-values change over time

![](images/ezgif.com-gif-maker%20(2).gif){fig-align="center"}

We can tell that from July 2021 to September 2021, the areas of significant p-values seem to be around the Northern and Central areas.

From October 2021 to June 2022, the North-East, Central and Southern areas seem to be the locations with significant p-values instead.

### 4.6.3 Statistical conclusions

For the Sub-Districts with p-value of Gi\* \< 0.05, the Gi\* values of the monthly vaccination rates of these locations are significant. The Gi\* values of these locations are either significantly high (around 2 to 6) or significantly low (around -2 to -6).

Throughout the 12 months, there were 128 Sub-Districts with at least 1 month of having a significant Gi\* value.

The Gi\* value of the vaccination rates for all 12 months were significant for Sub-Districts "BATU AMPAR", "CIPINANG CEMPEDAK", "GLODOK", "KAMPUNG BALI", "KAMPUNG TENGAH", "KEAGUNGAN", "KEBON KACANG", "KEBON MELATI", "MANGGA BESAR", "PETAMBURAN". This means that the vaccination rates for 12 months for these Sub-Districts were either significantly high or low.

## 4.7 Emerging Hot Spot Analysis (EHSA)

### 4.7.1 Mann-Kendall Test

In this section, we will perform the Mann-Kendall Test using the spatio-temporal local Gi\* values on 3 Sub-Districts.

#### 4.7.1.1 Sub-District 1 - "HALIM PERDANA KUSUMAH"

Firstly, on Sub-District "HALIM PERDANA KUSUMAH":

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg <- gi_stars |>
  ungroup() |>
  filter(Sub_District == "HALIM PERDANA KUSUMAH") |>
  select(Sub_District, Date, gi_star)
```

Plotting the result using ggplot2 functions

```{r}
#| code-fold: true
#| code-summary: Show the code!
ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()
```

Interactive plot using `ggplotly()` of plotly package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
p <- ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()

ggplotly(p)
```

p-value of Mann Kendall Test:

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

The p-value is 0.08 which is \> 0.05 hence p-value is not significant. This result tells us that here is an overall upward but insignificant trend.

#### 4.7.1.2 Sub-District 2 - "CIPAYUNG"

Secondly, on Sub-District "CIPAYUNG":

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg <- gi_stars |>
  ungroup() |>
  filter(Sub_District == "CIPAYUNG") |>
  select(Sub_District, Date, gi_star)
```

Plotting the result using ggplot2 functions

```{r}
#| code-fold: true
#| code-summary: Show the code!
ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()
```

Interactive plot using `ggplotly()` of plotly package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
p <- ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()

ggplotly(p)
```

p-value of Mann Kendall Test:

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

The p-value is 0.11 which is \> 0.05 hence p-value is not significant. This result tells us that here is an overall steep upward but insignificant trend.

#### 4.7.1.3 Sub-District 3 - "ANCOL"

Thirdly, on Sub-District "ANCOL":

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg <- gi_stars |>
  ungroup() |>
  filter(Sub_District == "ANCOL") |>
  select(Sub_District, Date, gi_star)
```

Plotting the result using ggplot2 functions

```{r}
#| code-fold: true
#| code-summary: Show the code!
ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()
```

Interactive plot using `ggplotly()` of plotly package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
p <- ggplot(data = cbg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()

ggplotly(p)
```

p-value of Mann Kendall Test:

```{r}
#| code-fold: true
#| code-summary: Show the code!
cbg %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

The p-value is 0.24 which is \> 0.05 hence p-value is not significant. This result tells us that here is an overall steep downward but insignificant trend.

### 4.7.2 EHSA map of the Gi\* values of the vaccination rate

To find out the significant emerging hot/cold spots, we would need to perform the Mann Kendall Test for each location. We can use `group_by()` of dplyr package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
ehsa <- gi_stars %>%
  group_by(Sub_District) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots:

```{r}
#| code-fold: true
#| code-summary: Show the code!
emerging <- ehsa %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
emerging
```

Performing Emerging Hotspot Analysis using `emerging_hotspot_analysis()` of sfdep package:

```{r}
#| code-fold: true
#| code-summary: Show the code!
ehsa <- emerging_hotspot_analysis(
  x = vacc_rate_st,
  .var = "Vaccination_Rate",
  k = 1,
  nsim = 99
)
```

Notes:

-   It takes a spacetime object x (i.e. varr_rate_st)
-   and the quoted name of the variable of interest (i.e. Vaccination_Rate) for .var argument
-   k argument is used to specify the number of time lags which is set to 1 by default
-   nsim map numbers of simulation to be performed

Visualisation of the distribution of EHSA classes using ggplot2 functions:

```{r}
#| code-fold: true
#| code-summary: Show the code!
ggplot(data = ehsa,
       aes(x=classification, fill=classification)) + 
  geom_bar()
```

The figure shows that the oscillating hot spot class has the highest number of Sub-Districts.

Before we can visualise the geographic distribution of the EHSA classes, we need to join `combined_jakarta` and `ehsa` together:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta_ehsa <- combined_jakarta %>%
  left_join(ehsa, by = c("Sub_District" = "location"))
```

Next, we can plot a categorical choropleth map for the significant locations using tmap functions:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# this adds a new column "NewClassification" so that we can include a class called "insignificant" in our plot
combined_jakarta_ehsa <- combined_jakarta_ehsa %>% mutate(NewClassification = 
                                                            case_when(p_value < 0.05 ~ classification,
                                                                      p_value >= 0.05 ~ "insignificant"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tm_shape(combined_jakarta_ehsa) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(combined_jakarta_ehsa) +
  tm_fill("NewClassification",
          palette = c("#ffffff", "#2c7bb6", "#abd9e9", "#fdae61", "#d7191c")) + 
  tm_borders(alpha = 0.4)
```

#### 4.7.2.1 Observations of the spatial patterns

Among the significant places, the number of locations being classified as oscillating hotspot is the greatest, followed by sporadic coldspot, oscillating coldspot, and no pattern detected.

The oscillating hotspots are spread out almost evenly in the whole of Jakarta since there are so many of them.

The sporadic coldspots are spread out slightly less evenly than the oscillating hotspots since the borders are not covered as much and they seem to be mainly at the Central area.

The oscillating coldspots seem to be spread quite evenly, around the Southern, Western and Central area. They seem to be less obvious at the Northern borders.

Lastly, the locations where no patterns are detected seem to be mainly in the Central area with the rest of the locations at different parts of Jakarta.

The areas where the patterns are insignificant appears to be mostly at the Central area and a little at the Western and Southern area.

# 5 References

Thank you to Prof Kam for the course teachings and reference materials!

Thank you to Senior Megan Sim for the reference - [Take Home Exercise 1](https://is415-msty.netlify.app/posts/2021-09-10-take-home-exercise-1/)
