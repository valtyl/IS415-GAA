---
title: "Take-home Exercise 2: Spatio-temporal Analysis of COVID-19 Vaccination Trends at the Sub-district Level, DKI Jakarta"
execute: 
  message: true
  warning: false
  echo: true
  eval: true
date: "13 February 2023"
date-modified: "`r Sys.Date()`"
# number-sections: true
editor: visual
format: html
author: Valencia
---

# 1 Setting the Scene

Since late December 2019, an outbreak of a novel coronavirus disease (COVID-19; previously known as 2019-nCoV) was reported in Wuhan, China, which had subsequently affected 210 countries worldwide. In general, COVID-19 is an acute resolved disease but it can also be deadly, with a 2% case fatality rate.

The COVID-19 vaccination in Indonesia is an ongoing mass immunisation in response to the COVID-19 pandemic in Indonesia. On 13 January 2021, the program commenced when President Joko Widodo was vaccinated at the presidential palace. In terms of total doses given, Indonesia ranks third in Asia and fifth in the world.

According to wikipedia, as of 5 February 2023 at 18:00 WIB (UTC+7), 204,266,655 people had received the first dose of the vaccine and 175,131,893 people had been fully vaccinated; 69,597,474 of them had been inoculated with the booster or the third dose, while 1,585,164 had received the fourth dose. Jakarta has the highest percentage of population fully vaccinated with 103.46%, followed by Bali and Special Region of Yogyakarta with 85.45% and 83.02% respectively.

Despite its compactness, the cumulative vaccination rate are not evenly distributed within DKI Jakarta. The question is where are the sub-districts with relatively higher number of vaccination rate and how they changed over time.

# 2 Objectives

Exploratory Spatial Data Analysis (ESDA) hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate Local Indicators of Spatial Association (LISA) and Emerging Hot Spot Analysis (EHSA) to undercover the spatio-temporal trends of COVID-19 vaccination in DKI Jakarta.

# 3 The Data

## 3.1 Aspatial Data

For the purpose of this assignment, data from [Riwayat File Vaksinasi DKI Jakarta](https://riwayat-file-vaksinasi-dki-jakarta-jakartagis.hub.arcgis.com/) will be used. Daily vaccination data are provides. You are only required to download either the first day of the month or last day of the month of the study period.

## 3.2 Geospatial Data

For the purpose of this study, DKI Jakarta administration boundary 2019 will be used. The data set can be downloaded at Indonesia Geospatial portal, specifically at [this page](https://www.indonesia-geospasial.com/2020/04/download-shapefile-shp-batas-desa.html).

::: callout-note
-   The national Projected Coordinates Systems of Indonesia is DGN95 / Indonesia TM-3 zone 54.1.
-   Exclude all the outer islands from the DKI Jakarta sf data frame, and
-   Retain the first nine fields in the DKI Jakarta sf data frame. The ninth field JUMLAH_PEN = Total Population.
:::

# 4 Getting Started

## 4.1 Installing and Loading R packages

-   [sf](https://r-spatial.github.io/sf/): to import, manage, and process geospatial data
-   [tidyverse](https://www.tidyverse.org/): a collection of packages ([readr](https://readr.tidyverse.org/) for importing delimited text file, [tidyr](https://tidyr.tidyverse.org/) for tidying data, [dplyr](https://dplyr.tidyverse.org/) for wrangling data)
-   [tmap](https://cran.r-project.org/web/packages/tmap/): provides functions for plotting cartographic quality static point patterns maps or interactive maps
-   [sfdep](https://cran.r-project.org/web/packages/sfdep/): for spatial dependence of simple features
-   [readxl](https://readxl.tidyverse.org/reference/read_excel.html): for importing Excel worksheets(.xlsx)
-   [plyr](https://cran.r-project.org/package=plyr): for splitting data, applying functions and combining results
-   [kableExtra](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html): for table customisation
-   [Kendall](https://cran.r-project.org/package=Kendall): for Mann-Kendall Test

```{r}
#| code-fold: true
#| code-summary: Show the code!
pacman::p_load(sf, sfdep, readxl, plyr, kableExtra, tmap, Kendall, tidyverse)
```

## 4.2 Data Wrangling: Geospatial Data

### 4.2.1 Importing the Geospatial Data

```{r}
#| code-fold: true
#| code-summary: Show the code!
# bd stands for "batas desa", translated as "village boundary"
# reads in geospatial data and stores into bd_jakarta dataframe
bd_jakarta <- st_read(dsn = "data/geospatial",
                       layer = "BATAS_DESA_DESEMBER_2019_DUKCAPIL_DKI_JAKARTA")
```

From the output message, we learn that: - Geometry type: Multipolygon - 269 features, 161 fields - Assigned CRS is [WGS 84](https://epsg.io/4326), 'World Geodetic System 1984' (This is not appropriate as this geospatial dataset is Indonesian-specific hence we will have to use the national CRS of Indonesia, [DGN 95](https://epsg.io/23845), 'Datum Geodesi Nasional 1995'. We will change this later on.) (Refer to note in section 3.2)

### 4.2.2 Data Pre-Processing

Before visualising our data, we need to check if there are: - invalid geometries - or missing values These can impact future calculations and representations

#### 4.2.2.1 Invalid Geometries

Checking for invalid geometries:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# function breakdown:
# the st_is_valid function checks whether a geometry is valid
# which returns the indices of certain values based on logical conditions
# length returns the length of data objects

# checks for the number of geometries that are NOT valid
length(which(st_is_valid(bd_jakarta) == FALSE))
```

The message output shows that there are no invalid geometries.

#### 4.2.2.2 Missing Values

```{r}
#| code-fold: true
#| code-summary: Show the code!
# the rowSums(is.na(bd_jakarta))!=0 checks every row if there are NA values, returning TRUE or FALSE
# the bd_jakarta 'wrapper' prints said rows that contain NA values
bd_jakarta[rowSums(is.na(bd_jakarta))!=0,]
```

The message output shows that there are 2 rows with missing values for the columns `KAB_KOTA` (City), `KECAMATAN` (District), `DESA_KELUR` (Village) and a few more others. We can also see that there are way too many columns, and we will remove the unnecessary columns later on.

To clean up, we will remove the rows that have NA values in `DESA_KELUR` since we are interested in the dataset on a sub-district level:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# removes rows that have an NA value in DESA_KELUR
# in context of this data, we can use other columns, such as KAB_KOTA or KECAMATAN
# but since we're looking at this on a sub-district level, DESA_KELUR seemed most appropriate
bd_jakarta <- na.omit(bd_jakarta,c("DESA_KELUR"))
```

#### 4.2.2.3 Verifying & Transforming the Coordinate System

Checking the CRS of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# retrieves the coordinate system of bd_jakarta
st_crs(bd_jakarta)
```

As mentioned in section 4.2.1, WGS 84 is not appropriate and we should change it to DGN 95:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# transforms the CRS to DGN95, ESPG code 23845
bd_jakarta <- st_transform(bd_jakarta, 23845)
```

Checking if the CRS has been properly assigned:

```{r}
#| code-fold: true
#| code-summary: Show the code!
st_crs(bd_jakarta)
```

The transformation is done.

### 4.2.3 Data Visualisation

First, we will visualise the geometry of Jakarta:

```{r}
#| code-fold: true
#| code-summary: Show the code!
plot(st_geometry(bd_jakarta))
```

From the output, it shows that `bd_jakarta` includes the main land but also many other outer islands that we are not relevant to our analysis in this assignment. (Refer to note in section 3.2)

To remove the outer islands, we should look at how unique values at the City level, `KAB_KOTA`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# outputs unique values of the KAB_KOTA field
unique(bd_jakarta$"KAB_KOTA")
```

From the output, the cities within Jakarta have a JAKARTA prefix, while KEPULAUAN SERIBU (which means 'Thousand Islands') refers to the outer islands. Visualising `KAB_KOTA` will confirm this:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# with bd_jakarta as the input data (setting the 'base')
# draw the KAB_KOTA (city) polygons
# essentially shades the map according to the city divisions
tm_shape(bd_jakarta) + 
  tm_polygons("KAB_KOTA")
```

The above visualisation proves that KEPULAUAN SERIBU are the outer islands to remove:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# filters out the outer islands by accepting only if the value of KAB_KOTA is NOT KEPULAUAN SERIBU
bd_jakarta <- filter(bd_jakarta, KAB_KOTA != "KEPULAUAN SERIBU")
```

### 4.2.4 Retaining relavant columns only

As seen in section 4.2.2.2, there were many unnecessary and irrelevant columns that we could remove. (Refer to note in section 3.2)

Retaining the relevant fields (first 9 fields) to our analysis:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# filters out other fields by accepting only the first 9 fields
bd_jakarta <- bd_jakarta[, 0:9]
```

### 4.2.5 Renaming the Columns in English

For ease of comprehension:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# with reference to: https://www.codegrepper.com/code-examples/r/rename+column+name+in+r
# renames the columns in the style New_Name = OLD_NAME
bd_jakarta <- bd_jakarta %>% 
  dplyr::rename(
    Object_ID=OBJECT_ID,
    Province=PROVINSI, 
    City=KAB_KOTA, 
    District=KECAMATAN, 
    Village_Code=KODE_DESA, 
    Village=DESA, 
    Sub_District=DESA_KELUR,
    Code=KODE, 
    Total_Population=JUMLAH_PEN
    )
```

### 4.2.6 Brief EDA of Geospatial Data

Summary of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# reveals the data type of all fields + some values
glimpse(bd_jakarta)
```

Number of unique sub-districts:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"Sub_District"))
```

Number of unique districts:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"District"))
```

Number of unique cities:

```{r}
#| code-fold: true
#| code-summary: Show the code!
length(unique(bd_jakarta$"City"))
```

There are 261 unique sub-districts, 42 unique districts and 5 unique cities. The maximum number of categories for mapping with tmap is 30. Even though max.categories can be adjusted in tmap_options, too many segmented sections on a single map will not provide much insights hence we should do the EDA at 'City' level:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# shades the map according to the city divisions
tm_shape(bd_jakarta) + 
  tm_polygons("City")
```

## 4.3 Data Wrangling: Aspatial Data

### 4.3.1 Pre-Importing EDA

For the aspatial data, I have decided to download the data for last day of every month from July 2021 to June 2022. However, the last day of Feb 2022 provided on the website in section 3.1 is 27 Feb instead of 28 Feb.

This section is to check for any discrepancies in each .xlsx file in the 'data/aspatial' folder by performing EDA:

```{r}
#| code-fold: true
#| code-summary: Show the code!
jul2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Juli 2021).xlsx")
glimpse(jul2021)
```

The above output shows that there are no duplicates for the columns.

Below, similar codes were used to check for the other excel files. There are no duplicates in the rest of the files. But, the excel files for July 2021 to February 2022 have 27 columns while those for March 2022 to June 2022 have 34 columns.

```{r}
#| code-fold: true
#| code-summary: Show the code!
aug2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Agustus 2021).xlsx")
glimpse(aug2021)

sep2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 September 2021).xlsx")
glimpse(sep2021)

oct2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Oktober 2021).xlsx")
glimpse(oct2021)

nov2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 November 2021).xlsx")
glimpse(nov2021)

dec2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Desember 2021).xlsx")
glimpse(dec2021)

jan2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Januari 2022).xlsx")
glimpse(jan2022)

feb2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (27 Februari 2022).xlsx")
glimpse(feb2022)

mar2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Maret 2022).xlsx")
glimpse(mar2022)

apr2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 April 2022).xlsx")
glimpse(apr2022)

may2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Mei 2022).xlsx")
glimpse(may2022)

jun2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 Juni 2022).xlsx")
glimpse(jun2022)
```

### 4.3.2 Creating an Aspatial Data Pre-processing Function

Firstly, here are some requirements for our aspatial data:

Columns of interest:

-   KODE KELURAHAN: sub-district code
-   KELURAHAN: sub-district
-   SASARAN: target
-   BELUM VAKSIN: not yet vaccinated
-   TOTAL VAKSIN DIBERIKAN: total vaccine administered

We need to create an extra Date column that has the month and year of the observation. Note that the files have a naming convention "Data Vaksinasi Berbasis Kelurahan (DD Month YYYY).xlsx"

```{r}
#| code-fold: true
#| code-summary: Show the code!
# takes in an aspatial data filepath and returns a processed output
aspatial_preprocess <- function(filepath){
  # we use [-1,] to remove the first row of the file as the first row is a subheader row
  result_file <- read_xlsx(filepath)[-1,]
  
  # Create the Date Column
  # the format of our files is: Data Vaksinasi Berbasis Kelurahan (DD Month YYYY)
  # while the start is technically "(", "(" is part of a regular expression and leads to a warning message, so we'll use "Kelurahan" instead. The [[1]] refers to the first element in the list.
  # we're loading it as DD-Month-YYYY format
  # to get the end index, we use the length of the filepath - 6 
  # as such, the most relevant functions are substr (returns a substring) and either str_locate (returns location of substring as an integer matrix) or gregexpr (returns a list of locations of substring)
  # reference https://stackoverflow.com/questions/14249562/find-the-location-of-a-character-in-string
  startpoint <- gregexpr(pattern="Kelurahan", filepath)[[1]] + 11
  
  result_file$Date <- substr(filepath, startpoint, nchar(filepath)-6)
  
  # Retain the Relevant Columns
  result_file <- result_file %>% 
    select("Date", 
           "KODE KELURAHAN", 
           "KELURAHAN", 
           "SASARAN", 
           "BELUM VAKSIN", 
           "TOTAL VAKSIN\r\nDIBERIKAN")
  return(result_file)
}
```

### 4.3.3 Importing the Aspatial Data

Feeding Files into the `aspatial_preprocess` function using list.files() and [lapply()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply) to apply a function to all elements in the list:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# in the folder 'data/aspatial', find files with the extension '.xlsx' and add it to our fileslist 
# the full.names=TRUE prepends the directory path to the file names, giving a relative file path - otherwise, only the file names (not the paths) would be returned 
# reference: https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html
fileslist <-list.files(path = "data/aspatial", pattern = "*.xlsx", full.names=TRUE)

# afterwards, for every element in fileslist, apply aspatial_process function
dflist <- lapply(seq_along(fileslist), function(x) aspatial_preprocess(fileslist[x]))
```

Converting the `dflist` into an actual dataframe using [ldply()](https://www.rdocumentation.org/packages/plyr/versions/1.8.6/topics/ldply):

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta <- ldply(dflist, data.frame)
```

Checking `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
glimpse(vacc_jakarta)
```

### 4.3.4 Formatting Date Column

The Dates are currently in string format as there were derived from the file names, hence we need to convert the Dates into datetime format.

```{r}
#| code-fold: true
#| code-summary: Show the code!
# parses the 'Date' column into Month(Full Name)-YYYY datetime objects
# reference: https://stackoverflow.com/questions/53380650/b-y-date-conversion-gives-na

# locale="ind" means that the locale has been set as Indonesia
Sys.setlocale(locale="ind")
```

Converting to datetime format:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta$Date <- c(vacc_jakarta$Date) %>% 
  as.Date(vacc_jakarta$Date, format ="%d %B %Y")

glimpse(vacc_jakarta)
```

### 4.3.4 Renaming Columns to English

Renaming columns to English for ease of comprehension:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# renames the columns in the style New_Name = OLD_NAME
vacc_jakarta <- vacc_jakarta %>% 
  dplyr::rename(
    Date=Date,
    Sub_District_Code=KODE.KELURAHAN,
    Sub_District=KELURAHAN, 
    Target=SASARAN, 
    Not_Yet_Vaccinated=BELUM.VAKSIN, 
    Total_Vaccine_Administered=TOTAL.VAKSIN..DIBERIKAN
    )
```

### 4.3.5 Further Data Processing

After finalising the dataframe, we can proceed with other data processing requirements.

Checking for missing values:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# returns rows that contain NA values
vacc_jakarta[rowSums(is.na(vacc_jakarta))!=0,]
```

From the output, there are no missing values.

## 4.3 Geospatial Data Integration

### 4.3.1 Preliminary joining + EDA

We need to join the geospatial and aspatial data frames but we first need to see what they both commonly have.

Check column names of `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
colnames(bd_jakarta)
```

Check column names of `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
colnames(vacc_jakarta)
```

We are able to see that we can join the dataframes with `Sub_District` and `Sub_District_Code`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta <- left_join(bd_jakarta, vacc_jakarta,
                              by=c(
                                "Sub_District"="Sub_District", 
                             "Village_Code"="Sub_District_Code")
                              )
```

Visualising combined_jakarta in terms of vaccine administered and total population:

```{r}
#| code-fold: true
#| code-summary: Show the code!

vaccine_administered = tm_shape(combined_jakarta)+
  tm_fill("Total_Vaccine_Administered") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Vaccine Administered Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Total Count")

tmap_arrange(vaccine_administered, total_population)
```

There are some missing values even though there are no rows with missing values. This could be due to the mismatch in the values due to slightly different namings for the same sub-district when the left join was done.

### 4.3.2 Identifying Mismatched Sub-District Records

Checking for unique values of Sub-District in `vacc_jakarta` but not in `bd_jakarta` and vice versa:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_subdistrict <- c(vacc_jakarta$Sub_District)
bd_subdistrict <- c(bd_jakarta$Sub_District)

unique(vacc_subdistrict[!(vacc_subdistrict %in% bd_subdistrict)])
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
unique(bd_subdistrict[!(bd_subdistrict %in% vacc_subdistrict)])
```

Table to view difference in naming:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# initialise a dataframe of our cases vs bd subdistrict spelling
spelling <- data.frame(
  Aspatial_Cases=c("BALE KAMBANG", "HALIM PERDANA KUSUMAH", "JATI PULO", "KAMPUNG TENGAH", "KERENDANG", "KRAMAT JATI", "PAL MERIAM", "PINANG RANTI", "RAWA JATI"),
  Geospatial_BD=c("BALEKAMBAG", "HALIM PERDANA KUSUMA", "JATIPULO", "TENGAH", "KRENDANG", "KRAMATJATI", "PALMERIAM", "PINANGRANTI", "RAWAJATI")
  )

# with dataframe a input, outputs a kable
library(knitr)
library(kableExtra)
kable(spelling, caption="Mismatched Records") %>%
  kable_material("hover", latex_options="scale_down")
```

Correcting the mismatched sub-district records in `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# where bd_jakarta is a mismatched value, replace with the correct value
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'BALEKAMBANG'] <- 'BALE KAMBANG'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'HALIM PERDANA KUSUMA'] <- 'HALIM PERDANA KUSUMAH'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'JATIPULO'] <- 'JATI PULO'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KALI BARU'] <- 'KALIBARU'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'TENGAH'] <- 'KAMPUNG TENGAH'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KRAMATJATI'] <- 'KRAMAT JATI'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'KRENDANG'] <- 'KERENDANG'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'PALMERIAM'] <- 'PAL MERIAM'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'PINANGRANTI'] <- 'PINANG RANTI'
bd_jakarta$Sub_District[bd_jakarta$Sub_District == 'RAWAJATI'] <- 'RAWA JATI'
```

There are 6 more unique values in `vacc_jakarta` as those values are data referring to the outer islands looking at the fact that WILAYAH KOTA is not in JAKARTA:

![](images/jakarta_outer_islands.png)

Thus, we need to remove the rows with these outer islands data:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta <- vacc_jakarta[!(vacc_jakarta$Sub_District=="PULAU HARAPAN" | vacc_jakarta$Sub_District=="PULAU KELAPA" | vacc_jakarta$Sub_District=="PULAU PANGGANG" | vacc_jakarta$Sub_District=="PULAU PARI" | vacc_jakarta$Sub_District=="PULAU TIDUNG" | vacc_jakarta$Sub_District=="PULAU UNTUNG JAWA"), ]
```

Re-checking for rows with NA values in `vacc_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_jakarta[rowSums(is.na(vacc_jakarta))!=0,]
```

Re-checking for rows with NA values in `bd_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
bd_jakarta[rowSums(is.na(bd_jakarta))!=0,]
```

### 4.3.3 Re-joining the geospatial and aspatial data frames + EDA

```{r}
#| code-fold: true
#| code-summary: Show the code!
# joins vacc_jakarta to bd_jakarta based on Sub_District
combined_jakarta <- left_join(bd_jakarta, vacc_jakarta,
                              by=c("Sub_District"="Sub_District")
                              )
```

Checking for rows with NA values in `combined_jakarta`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta[rowSums(is.na(combined_jakarta))!=0,]
```

Visualising combined_jakarta in terms of vaccine administered and total population again:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vaccine_administered = tm_shape(combined_jakarta)+
  tm_fill("Total_Vaccine_Administered") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Updated Vaccine Administered Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Updated Total Count")

tmap_arrange(vaccine_administered, total_population)
```

## 4.4 Calculation for Vaccination Rate

We need to compute the monthly vaccination rate: vaccination rate (in %) = (total population - number of people not vaccinated yet) / total population \* 100

```{r}
#| code-fold: true
#| code-summary: Show the code!
# grouping based on the sub-district and date
# the cumulative_case_rate is based on the sum of cases over the total population
vacc_rate <- vacc_jakarta %>%
  inner_join(bd_jakarta, by=c("Sub_District" = "Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`vacc_rate` = ((Total_Population-Not_Yet_Vaccinated)/Total_Population)*100) %>%
  
  #afterwards, pivots the table based on the Dates, using the cumulative case rate as the values
  ungroup() %>% pivot_wider(names_from = Date,
              values_from = vacc_rate)
```

Show Vaccination Rate:

```{r}
#| code-fold: true
#| code-summary: Show the code!
vacc_rate
```

### 4.4.1 Converting dataframes to sf objects

Before moving on to mapping, we should convert dataframes into sf objects

Converting `combined_jakarta` and `vacc_rate`:

```{r}
#| code-fold: true
#| code-summary: Show the code!
combined_jakarta <- st_as_sf(combined_jakarta)

# need to join our previous dataframes with the geospatial data to ensure that geometry column is present
vacc_rate <- vacc_rate%>% left_join(bd_jakarta, by=c("Sub_District"="Sub_District"))
vacc_rate <- st_as_sf(vacc_rate)
```

## 4.5 Choropleth Mapping and Analysis

There are different data classifications to choropleth maps like equal intervals, quantile, jenks and standard deviation. I have decided to use Jenks as it minimises variation in each class. It will be able to find suitable class ranges and also group outliers in a class of its own.

### 4.5.1 Jenks Choropleth Map

As we do not want too many classes, we will use 6 classes as it seems to be the optimum number to view different classes and we will be able to differentiate between the classes without straining our eyes.

Map for Jul 2021:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# using the jenks method, with 6 classes
tmap_mode("plot")
tm_shape(vacc_rate)+
  tm_fill("2021-07-31", 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
  tm_layout(main.title = "Distribution of Vaccination Rate in July 2021",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.5, 
            legend.width = 0.4,
            frame = TRUE) +
  tm_borders(alpha = 0.5)
```

Introducing a helper function to help us plot the maps for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
# input: the dataframe and the variable name - in this case, the month 
# with style="jenks" for the jenks classification method
jenks_plot <- function(df, varname) {
  tm_shape(vacc_rate) +
    tm_polygons() +
  tm_shape(df) +
    tm_fill(varname, 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
    tm_layout(main.title = varname,
          main.title.position = "center",
          main.title.size = 1.2,
          legend.height = 0.45, 
          legend.width = 0.35,
          frame = TRUE) +
    tm_borders(alpha = 0.5)
}
```

Visualising the Jenks Maps for all 12 months:

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2021-07-31"),
             jenks_plot(vacc_rate, "2021-08-31"),
             jenks_plot(vacc_rate, "2021-09-30"),
             jenks_plot(vacc_rate, "2021-10-31"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2021-11-30"),
             jenks_plot(vacc_rate, "2021-12-31"),
             jenks_plot(vacc_rate, "2022-01-31"),
             jenks_plot(vacc_rate, "2022-02-27"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(jenks_plot(vacc_rate, "2022-03-31"),
             jenks_plot(vacc_rate, "2022-04-30"),
             jenks_plot(vacc_rate, "2022-05-31"),
             jenks_plot(vacc_rate, "2022-06-30"))
```

### 4.5.2 Observations from Jenks Choropleth Maps

For each map, they have their own relative vaccination rate as the range for each map differs. Hence, we cannot rely on the colour scale for each map to compare between the months as it would not be fair.

However, we are able to compare each month individually and see that typically for each month, the higher vaccination rates are at the central area and southern area.

Some other analysis can be done like the sub-district with the highest vaccination rate and the sub-district with the lowest vaccination rate for each month:

```{r}
#| code-fold: true
#| code-summary: Show the code!
#highest vaccination rate for each month
vacc_rate$Sub_District[which.max(vacc_rate$`2021-07-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-08-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-09-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-10-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-11-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2021-12-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-01-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-02-27`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-03-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-04-30`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-05-31`)]
vacc_rate$Sub_District[which.max(vacc_rate$`2022-06-30`)]
```

From this, we can tell that the sub-district "HALIM PERDANA KUSMAH" consistently has the highest vaccination rate except for 1 month in Aug 2021.

```{r}
#| code-fold: true
#| code-summary: Show the code!
#lowest vaccination rate for each month
vacc_rate$Sub_District[which.min(vacc_rate$`2021-07-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-08-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-09-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-10-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-11-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2021-12-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-01-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-02-27`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-03-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-04-30`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-05-31`)]
vacc_rate$Sub_District[which.min(vacc_rate$`2022-06-30`)]
```

From this, we can tell that initially the sub-district "BALE KAMBANG" had the lowest vaccination rate from July 2021 to August 2021, but their vaccination rate improved over the months such that "KALIBARU" was identified as the sub-district with the lowest vaccination rate from September 2021 to January 2022 with the exception of December 2021. Then, "KEBON MELATI" became the sub-district with the lowest vaccination rate from December 2021 to June 2022 with the exception of January 2022.

### 4.5.3 Spatio-Temporal Mapping with custom breakpoints

In the above section, each month had their own vaccination rate. To compare with the vaccination rate between months and see the spatio-temporal progression of the vaccination rates, we should set a fixed range.

To do so, we have to customise the breakpoints and following the above section, we will define 6 breakpoints.

First, we require the maximum vaccination rate which would be from the latest month (June 2022):

```{r}
#| code-fold: true
#| code-summary: Show the code!
max(vacc_rate$`2022-06-30`)
```

Now, we can define the 6 breakpoints based on the jenks breaks ranges from the above section:

```{r}
#| code-fold: true
#| code-summary: Show the code!
breakpoints = c(48, 65, 72, 82, 86, 92)
```

Creating a helper function for break plot:

```{r}
break_plot <- function(df, varname) {
  tm_shape(vacc_rate) +
    tm_polygons() +
  tm_shape(df) +
    tm_fill(varname, 
          breaks= breakpoints,
          title = "Vaccination Rate") +
    tm_layout(main.title = varname,
          main.title.position = "center",
          main.title.size = 1.2,
          legend.height = 0.45, 
          legend.width = 0.35,
          frame = TRUE) +
    tm_borders(alpha = 0.5)
}
```

Plotting the custom break plots for each month:

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2021-07-31"),
             break_plot(vacc_rate, "2021-08-31"),
             break_plot(vacc_rate, "2021-09-30"),
             break_plot(vacc_rate, "2021-10-31"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2021-11-30"),
             break_plot(vacc_rate, "2021-12-31"),
             break_plot(vacc_rate, "2022-01-31"),
             break_plot(vacc_rate, "2022-02-27"))
```

```{r}
#| code-fold: true
#| code-summary: Show the code!
tmap_mode("plot")
tmap_arrange(break_plot(vacc_rate, "2022-03-31"),
             break_plot(vacc_rate, "2022-04-30"),
             break_plot(vacc_rate, "2022-05-31"),
             break_plot(vacc_rate, "2022-06-30"))
```

### 4.5.4 Observations from Custom Breakplot Maps

![](images/ezgif.com-gif-maker.gif)

At the start, in July 2021 and August 2021, there is a slightly higher vaccination rate at the Northern area compared to the other areas given its slightly darker shade of yellow.

However as time passes, from September 2021 to October 2021, the increase in the vaccination rate becomes more evenly spread and there is not much obvious difference other than a few sub-districts here and there.

Specifically sub-district "HALIM PERDANA KUSUMAH" is obvious to the eye with its consistently high rate and darker shade.

From November 2021 to February 2022, the increase in vaccination rate is faster at the Southern area and the Northern Central Area then sub-districts at the Northern border start to catch up.

(Supplementing the previous observations in section 4.5.2, the general increasing trend happens at the Southern and Central area.)

From March 2022 to June 2022, we can see the sub-districts at the Northern border as well as some sub-districts in the central area increasing their vaccination rates.

## 4.6 Local Gi\* Analysis

### 4.6.1 Computing local Gi* values of the monthly vaccination rate
```{r}
wm_q <- combined_jakarta %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb, style='W'),
         .before=1)
```

```{r}
set.seed(1234)
```

```{r}
HCSA <- wm_q %>%
  mutate(local_Gi = local_gstar_perm(
    ((Total_Population-Not_Yet_Vaccinated)/Total_Population*100), nb, wt, nsim=99),
    .before=1) %>%
  unnest(local_Gi)
HCSA
```


### 4.6.2 Displaying the Gi* maps of the monthly vaccination rate

Visualising Gi*:
```{r}
tmap_mode("view")
tm_shape(HCSA) +
  tm_fill("gi_star") +
  tm_borders(alpha=0.5) + 
  tm_view(set.zoom.limits = c(10,16))
```

Visualising p-value of HCSA:
```{r}
tmap_mode("plot")
tm_shape(HCSA) +
  tm_fill("p_sim") +
  tm_borders(alpha=0.5) + 
  tm_view(set.zoom.limits = c(10,16))
```


### 4.6.3 Statistical conclusions


## 4.7 Emerging Hot Spot Analysis (EHSA)

Making an attribute table:
```{r}
# make new vaccination attribute table with Date, Sub_District, Total_Population, Not_Yet_Vaccinated
vacc_attribute_table <- combined_jakarta %>% select(10, 8, 9, 13) %>% st_drop_geometry()

# add a new field for Vaccination_Rate
vacc_attribute_table$Vaccination_Rate <- (vacc_attribute_table$Total_Population - vacc_attribute_table$Not_Yet_Vaccinated) / vacc_attribute_table$Total_Population*100

# final vaccination attribute table with Date, Sub_District, Vaccination_Rate
vacc_attribute_table <- tibble(vacc_attribute_table %>% select(1,2,5))
```

Display attribute table details:
```{r}
vacc_attribute_table
```

Creating a time series cube:
```{r}
vacc_rate_st <- spacetime(vacc_attribute_table, bd_jakarta,
                          .loc_col = "Sub_District",
                          .time_col = "Date")
```

```{r}
vacc_rate_st
```

```{r}
vacc_rate_nb <- vacc_rate_st %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_weights(nb)
         ) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

Computing Gi*:
```{r}
gi_stars <- vacc_rate_nb |>
  group_by(Date) |>
  mutate(gi_star = local_gstar_perm(
    Vaccination_Rate, nb, wt, nsim=99)) |>
      tidyr::unnest(gi_star)
```

```{r}
gi_stars
```


### 4.7.1 Mann-Kendall Test

```{r}
chg <- gi_stars |>
  ungroup() |>
  filter(Sub_District == "HALIM PERDANA KUSUMAH") |>
  select(Sub_District, Date, gi_star)
```

```{r}
chg
```


```{r}
ggplot(data = chg,
       aes(x = Date,
           y = gi_star)) + 
  geom_line() + 
  theme_light()
```


### 4.7.2 EHSA map of the Gi* values of the vaccination rate
```{r}
ehsa <- emerging_hotspot_analysis(
  x = vacc_rate_st,
  .var = "Vaccination_Rate",
  k = 1,
  nsim = 99
)
```

```{r}
ggplot(data = ehsa,
       aes(x=classification)) + 
  geom_bar()
```


# 5 References
